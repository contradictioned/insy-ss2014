<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf-8">
    <title>Informationssysteme SS 2014 - Manuel Hoffmann</title>
    <meta name="description" content="">
    <style type="text/css">
    	table tr:nth-child(2n+1){
				background-color: #fff5dd;
			}
    </style>

    <script type="text/javascript">
    	function debug(s) {
    		console.log(s)
    	}

    	/*
    	 * Given a table, this function returns
    	 * the list of attributes.
    	 * E.g. on the table
    	 *   | id | name | street |
    	 *   | .....
    	 * it would return
    	 *   ['id', 'name', 'street']
    	 */
			function getAttrsFromTable(table) {
				var th_data = table.getElementsByTagName('th');
				var attrs = new Array(th_data.length);
				for(var i = 0; i < th_data.length; i++) {
					attrs[i] = th_data[i].innerHTML;
				}
				return attrs;
			}

			/*
			 * For a <tr>-Element and a list of attrs,
			 * this function creates an object where the
			 * keys are taken from attrs and the values
			 * from the innerHTML of the <td>s
			 */
			function rowToTuple(trNode, attrs) {
				var tuple = {};
				var tds = trNode.getElementsByTagName('td');
				for(var i = 0; i < attrs.length; i++) {
					tuple[attrs[i]] = tds[i].innerHTML;
				}
				return tuple;
			}

    	/*
    	 * Get the tuples stored in a table in form
    	 *   [
    	 *     {'pnr': 5, 'name': 'müller'},
    	 *     {'pnr': 3, 'name': 'meier'},
    	 *     ...
    	 *   ]
    	 */
    	function getTuples(table, attrs) {
    		var rows = table.getElementsByTagName('tbody')[0].getElementsByTagName('tr')
    		var tuples = new Array(rows.length);
    		for(var i = 0; i < rows.length; i++) {
    			tuples[i] = rowToTuple(rows[i], attrs);
    		}
    		return tuples
    	}

    	function fillTableHeader(table, attrs) {
    		var thead = document.createElement('thead');
    		var tr = document.createElement('tr');
    		thead.appendChild(tr);
    		for(var i = 0; i < attrs.length; i++) {
    			var th = document.createElement('th');
    			th.innerHTML = attrs[i];
    			tr.appendChild(th)
    		}
    		table.appendChild(thead);
    	}

    	/* 
    	 * Creates a <tr>-element from a tuple 
    	 */
    	function createRow(tuple, attrs) {
    		var tr = document.createElement('tr');
    		for(var i = 0; i < attrs.length; i++) {
    			var td = document.createElement('td')
    			td.innerHTML = tuple[attrs[i]];
    			tr.appendChild(td)
    		}
    		return tr
    	}

    	/*
    	 * Writes (1) the table header and
    	 *        (2) a row for every tuple
    	 * into the table.
    	 * Attenzione: Duplicates are preserved.
    	 */
    	function fillTableWithTuples(table, tuples, attrs) {
    		fillTableHeader(table, attrs);
    		
    		var tbody = document.createElement('tbody');
    		table.appendChild(tbody);
    		
    		for(var i = 0; i < tuples.length; i++) {
    			var el = createRow(tuples[i], attrs)
    			tbody.appendChild(el);
    		}
    	}

    	function project(tuple, plist) {
    		for(var name in tuple) {
    			if(plist.indexOf(name) == -1) {
    				// Attribute name is not in plist, so it will be deleted
    				delete tuple[name];
    			}
    		}
    		return tuple
    	}

    	/*
    	 * old is the old table
    	 * new is the new table
    	 */
    	function applySelection(oldT, newT, pred) {
    		var attrs = getAttrsFromTable(oldT);
    		var oldtuples = getTuples(oldT, attrs);
    		var newtuples = [];
    		for(var i = 0; i < oldtuples.length; i++) {
    			if(pred(oldtuples[i])) {
    				newtuples.push(oldtuples[i]);
    			}
    		}
    		fillTableWithTuples(newT, newtuples, attrs);
    	}

    	
    	/*
    	 * old is the old table
    	 * new is the new table
    	 */
    	function applyProjection(oldT, newT, plist) {
    		var oldAttrs = getAttrsFromTable(oldT);
    		var oldtuples = getTuples(oldT, oldAttrs);
    		var newtuples = new Array(oldtuples.length);
    		for(var i = 0; i < oldtuples.length; i++) {
    			newtuples[i] = project(oldtuples[i],plist);
    		}
    		fillTableWithTuples(newT, newtuples, plist);
    	}

    	function renameAttr(tuple, newA, oldA) {
    		if(tuple[oldA]) {
    			tuple[newA] = tuple[oldA];
    			delete tuple[oldA]
    		}
    		return tuple
    	}

   		/*
    	 * old is the old table
    	 * new is the new table
    	 */
    	function applyRename(oldT, newT, op) {
    		var attrs = getAttrsFromTable(oldT);
    		var oldtuples = getTuples(oldT, attrs);
    		var newtuples = new Array(oldtuples.length);

    		var matches = op.match(/(\w+)\s*(<-)\s*(\w+)/)
    		if(matches == null) {
    			// renaming of relation
	    		for(var i = 0; i < oldtuples.length; i++) {
	    			newtuples[i] = oldtuples[i]
	    		}
	    	} else {
	    		// renaming of an attribute
	    		debug(matches)
	    		debug(attrs)
	    		for(var i = 0; i < oldtuples.length; i++) {
	    			newtuples[i] = renameAttr(oldtuples[i],matches[1],matches[3]);
	    		}
    			idx = attrs.indexOf(matches[3])
    			debug(idx)
    			attrs[idx] = matches[1]
	    	}


    		fillTableWithTuples(newT, newtuples, attrs);
    	}

    	/*
    	 * Returns a strings which represents attributes
    	 * Attenzione: this may not be compatible with
    	 * the actual present attributes!
    	 */
    	function parseAttrlist(str) {
    		var arr = str.split(',')
    		for(var i = 0; i < arr.length; i++) {
    			arr[i] = arr[i].trim()
    		}
    		return arr;
    	}

    	// normalizes an operand
    	function operandToStr(str) {
    		if(/'\w+'|"\w+"|\d+/.test(str)) {
    			debug("I think, this is a digit or a string: " + str)
    			return str
    		}
    		debug("I think, this is a column: " + str)
    		return 'tuple.' + str
    	}

    	/*
    	 * Parses a string which represtens a predicate
    	 * that should be evaluated upon a tuple.
    	 * Supported operators:
    	 *   ==, !=, <, <=, >, >=
    	 * This function returns a function that can be
    	 * executed on a tuple and returns a boolean.
    	 * (I.e. str => (tuple => bool))
    	 */
    	function parsePred(str) {
    		var matches = str.match(/([\w|'|"]+)\s*(==|!=|<|>|<=|>=)\s*([\w|'|"]+)/)
    		debug(matches)
    		var op1 = operandToStr(matches[1])
    		var operator = matches[2]
    		var op2 = operandToStr(matches[3])
    		var fn = Function("tuple", "return " + op1 + operator + op2)
    		return fn
    	}

    	/************/
    	/* EXAMPLES */
    	/************/
    	function selectionDriver() {
    		var oldT = document.getElementById('example_table');
    		var newT = document.getElementById('result_table1');
    		newT.innerHTML = "";
    		var i = document.getElementById('input1');
    		var pred = parsePred(i.value)
    		applySelection(oldT, newT, pred);
    	}
    	function projectionDriver() {
    		var oldT = document.getElementById('example_table');
    		var newT = document.getElementById('result_table2');
    		newT.innerHTML = "";
    		var i = document.getElementById('input2');
    		plist = parseAttrlist(i.value)
    		applyProjection(oldT, newT, plist);
    	}
    	function renameDriver() {
    		var oldT = document.getElementById('example_table');
    		var newT = document.getElementById('result_table3');
    		newT.innerHTML = "";
    		var i = document.getElementById('input3');
    		applyRename(oldT, newT, i.value);
    	}
    </script>
  </head>
  <body>
		<table id="example_table">
			<caption>DA</caption>
			<thead>
				<tr>
					<th>PNR</th>
					<th>Figur</th>
				</tr>
			</thead>
			<tr>
				<td>1</td>
				<td>Wallenstein</td>
			</tr>
			<tr>
				<td>1</td>
				<td>Woyzeck</td>
			</tr>
			<tr>
				<td>1</td>
				<td>Faust</td>
			</tr>
			<tr>
				<td>2</td>
				<td>Wallenstein</td>
			</tr>
			<tr>
				<td>3</td>
				<td>Woyzeck</td>
			</tr>
			<tr>
				<td>4</td>
				<td>Faust</td>
			</tr>
			<tr>
				<td>4</td>
				<td>Wallenstein</td>
			</tr>
		</table>
		<hr />
		<p>Beispiel: Selektion</p>
		<button id="click1" onclick="selectionDriver()">&sigma;<sub>_</sub>(DA)</button>
		Prädikat: <input type="text" id="input1"/> (bisher unterstützt: <code>!=</code>, <code>==</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>
		. Leider <strong>noch keine</strong> Verknüpfung mehrerer Prädikate)
		<table id="result_table1"></table>
		<hr />
		<p>Beispiel: Projektion</p>
		<button id="click2" onclick="projectionDriver()">&pi;<sub>_</sub>(DA)</button>
		Attribute: <input type="text" id="input2"/> (als kommagetrennte Liste eingeben)
		<table id="result_table2"></table>
		<hr />
		<p>Beispiel: Umbenennung von Spalten</p>
		<button id="click3" onclick="renameDriver()">&rho;<sub>_</sub>(DA)</button>
		<input type="text" id="input3"/> (entweder "Name" oder "Neu&lt;-Alt")
		<table id="result_table3"></table>
  </body>
</html>