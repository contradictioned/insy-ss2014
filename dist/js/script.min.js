function debug(s) {
    console.log(s);
}

function BaseRelation(name) {
    this.name = name, this.result = new Relation();
}

function Cross(left, right) {
    this.left = left, this.right = right;
}

function NaturalJoin(left, right) {
    this.left = left, this.right = right;
}

function getJoinAttrs(l, r) {
    joinAttrs = [];
    for (var i = 0; i < l.length; i++) -1 != r.indexOf(l[i]) && joinAttrs.push(l[i]);
    return joinAttrs;
}

function Projection(attrs, relation) {
    this.attrs = attrs, this.relation = relation, this.indecesToStay = [];
}

function RelationRenaming(new_name, relation) {
    this.new_name = new_name, this.relation = relation;
}

function ColumnRenaming(renaming, relation) {
    this.renaming = renaming, this.relation = relation;
}

function Selection(predicate, relation) {
    this.predicate = predicate, this.relation = relation;
}

function applyProjection(oldT, newT, plist) {
    for (var oldAttrs = getAttrsFromTable(oldT), oldtuples = getTuples(oldT, oldAttrs), newtuples = new Array(oldtuples.length), i = 0; i < oldtuples.length; i++) newtuples[i] = project(oldtuples[i], plist);
    fillTableWithTuples(newT, newtuples, plist);
}

function Relation() {
    this.name = void 0, this.attributes = [], this.tuples = [];
}

function makeTablesExpendable() {
    var tables = document.getElementsByClassName("expendable"), decorator = document.createElement("span");
    decorator.classList.add("toggle"), decorator.innerHTML = "▼", decorator.style.cursor = "s-resize";
    for (var i = 0; i < tables.length; i++) {
        hideTable(tables[i]);
        var head = tables[i].getElementsByTagName("caption")[0], dec = decorator.cloneNode(!0);
        head.appendChild(dec), dec.onclick = toggleTable, foo = dec;
    }
}

function toggleTable() {
    var table = this.parentElement.parentElement, b = table.getElementsByTagName("tbody")[0];
    "none" == b.style.display ? (showTable(table), table.getElementsByClassName("toggle")[0].innerHTML = "▲", 
    table.getElementsByClassName("toggle")[0].style.cursor = "n-resize") : (hideTable(table), 
    table.getElementsByClassName("toggle")[0].innerHTML = "▼", table.getElementsByClassName("toggle")[0].style.cursor = "s-resize");
}

function hideTable(table) {
    var b = table.getElementsByTagName("tbody")[0];
    b.style.display = "none";
}

function showTable(table) {
    var b = table.getElementsByTagName("tbody")[0];
    b.style.display = "";
}

function execQuery() {
    var querystring = document.getElementById("input").value;
    debug("Onload function called for query: " + querystring), document.getElementById("error_output").innerHTML = "";
    var old = document.getElementById("result_output").getElementsByTagName("table");
    old.length > 0 && old[0].remove();
    try {
        result = QueryParser.parse(querystring);
    } catch (e) {
        document.getElementById("error_output").innerHTML = e;
    }
    result.eval();
    var table = build_table(result.result);
    document.getElementById("result_output").appendChild(table);
}

function prepareExamples() {
    for (var lis = document.getElementById("examples").getElementsByTagName("li"), i = 0; i < lis.length; i++) lis[i].onclick = insertExample;
}

function insertExample() {
    var str = this.innerHTML.replace("&lt;", "<");
    str = str.replace("&gt;", ">"), document.getElementById("input").value = str, execQuery();
}

function renameAttr(tuple, newA, oldA) {
    return tuple[oldA] && (tuple[newA] = tuple[oldA], delete tuple[oldA]), tuple;
}

function applyRename(oldT, newT, op) {
    var attrs = getAttrsFromTable(oldT), oldtuples = getTuples(oldT, attrs), newtuples = new Array(oldtuples.length), matches = op.match(/(\w+)\s*(<-)\s*(\w+)/);
    if (null == matches) for (var i = 0; i < oldtuples.length; i++) newtuples[i] = oldtuples[i]; else {
        debug(matches), debug(attrs);
        for (var i = 0; i < oldtuples.length; i++) newtuples[i] = renameAttr(oldtuples[i], matches[1], matches[3]);
        idx = attrs.indexOf(matches[3]), debug(idx), attrs[idx] = matches[1];
    }
    fillTableWithTuples(newT, newtuples, attrs);
}

function applySelection(oldT, newT, pred) {
    for (var attrs = getAttrsFromTable(oldT), oldtuples = getTuples(oldT, attrs), newtuples = [], i = 0; i < oldtuples.length; i++) pred(oldtuples[i]) && newtuples.push(oldtuples[i]);
    fillTableWithTuples(newT, newtuples, attrs);
}

function build_table(relation) {
    var table = document.createElement("table");
    table.classList.add("relation");
    var caption = document.createElement("caption");
    caption.innerHTML = "RESULT", table.appendChild(caption), fillTableHeader(table, relation.attributes);
    var tbody = document.createElement("tbody");
    table.appendChild(tbody), console.log(relation);
    for (var i = 0; i < relation.tuples.length; i++) {
        var el = createRow(relation.tuples[i], relation.attributes);
        tbody.appendChild(el);
    }
    return table;
}

function fillTableHeader(table, attrs) {
    var thead = document.createElement("thead"), tr = document.createElement("tr");
    thead.appendChild(tr);
    for (var i = 0; i < attrs.length; i++) {
        var th = document.createElement("th");
        th.innerHTML = attrs[i], tr.appendChild(th);
    }
    table.appendChild(thead);
}

function createRow(tuple, attrs) {
    for (var tr = document.createElement("tr"), i = 0; i < attrs.length; i++) {
        var td = document.createElement("td");
        td.innerHTML = tuple.values[i], tr.appendChild(td);
    }
    return tr;
}

function Tuple(a, v) {
    this.attributes = a, this.values = v;
}

BaseRelation.prototype.eval = function() {
    var table = this.findTable(this.name);
    this.result.name = this.name, this.result.attributes = this.getAttrsFromTable(table), 
    this.result.tuples = this.getTuples(table, this.result.attributes);
}, BaseRelation.prototype.getAttrsFromTable = function(table) {
    var th_data = table.getElementsByTagName("th");
    if (0 == th_data.length) throw "Table seems to have no columns.";
    for (var attrs = new Array(th_data.length), i = 0; i < th_data.length; i++) {
        var attr = th_data[i].innerHTML;
        attrs[i] = [ this.name, attr ];
    }
    return attrs;
}, BaseRelation.prototype.rowToTuple = function(trNode, attrs) {
    var tuple = new Tuple();
    tuple.values = new Array();
    for (var tds = trNode.getElementsByTagName("td"), i = 0; i < attrs.length; i++) tuple.values[i] = tds[i].innerHTML;
    return tuple;
}, BaseRelation.prototype.getTuples = function(table, attrs) {
    for (var rows = table.getElementsByTagName("tbody")[0].getElementsByTagName("tr"), tuples = new Array(rows.length), i = 0; i < rows.length; i++) tuples[i] = this.rowToTuple(rows[i], attrs);
    return tuples;
}, BaseRelation.prototype.findTable = function(tablename) {
    for (var tables = document.getElementsByClassName("relation"), i = 0; i < tables.length; i++) {
        var tcaption = tables[i].getElementsByTagName("caption")[0];
        if (0 === tcaption.innerText.indexOf(tablename)) return tables[i];
    }
    throw "No such relation defined";
}, Cross.prototype.eval = function() {
    this.left.eval(), this.right.eval();
    var left_res = this.left.result, right_res = this.right.result;
    this.result = new Relation(), this.result.attributes = left_res.attributes.concat(right_res.attributes);
    for (var i = 0; i < left_res.tuples.length; i++) for (var j = 0; j < right_res.tuples.length; j++) {
        var old_left = left_res.tuples[i].values, old_right = right_res.tuples[j].values, new_tuple = new Tuple();
        console.log(old_left), console.log(old_right);
        for (var k = 0; k < old_left.length; k++) new_tuple.values.push(old_left[k]);
        for (var k = 0; k < old_right.length; k++) new_tuple.values.push(old_right[k]);
        console.log(new_tuple), this.result.tuples.push(new_tuple);
    }
    console.log(this.result);
}, NaturalJoin.prototype.eval = function() {
    this.left.eval(), this.right.eval();
    var left_res = this.left.result, right_res = this.right.result;
    this.join_attrs = getJoinAttrs(this.left.attributes, this.right.attributes), this.result = new Array(), 
    this.attrs = new Array();
    for (var i = 0; i < this.left.attrs.length; i++) {
        var name = this.left.attrs[i];
        -1 == this.join_attrs.indexOf(name) && this.attrs.push(this.left.attrs[i]);
    }
    for (var i = 0; i < this.join_attrs.length; i++) this.attrs.push(this.join_attrs[i]);
    for (var i = 0; i < this.right.attrs.length; i++) {
        var name = this.right.attrs[i];
        -1 == this.join_attrs.indexOf(name) && this.attrs.push(this.right.attrs[i]);
    }
    for (var i = 0; i < left_res.length; i++) for (var j = 0; j < right_res.length; j++) {
        for (var old_left = left_res[i], old_right = right_res[j], joinme = !0, k = 0; k < this.join_attrs.length; k++) joinme = joinme && old_left[this.join_attrs[k]] == old_right[this.join_attrs[k]];
        if (joinme) {
            var new_tuple = {};
            for (var name in old_left) new_tuple[name] = old_left[name];
            for (var name in old_right) -1 == this.join_attrs.indexOf(name) && (new_tuple[name] = old_right[name]);
            this.result.push(new_tuple);
        }
    }
}, Projection.prototype.eval = function() {
    this.relation.eval();
    var child_res = this.relation.result;
    this.result = new Relation();
    for (var i = 0; i < child_res.attributes.length; i++) for (var cattr = child_res.attributes[i], j = 0; j < this.attrs.length; j++) if (-1 === this.attrs[j].indexOf(".") && this.attrs[j] == cattr[1] && (this.indecesToStay.push(i), 
    this.result.attributes.push(cattr)), this.attrs[j].indexOf(".") >= 0) {
        var split = this.attrs[j].split(".");
        split[0] == cattr[0] && split[1] == cattr[1] && (this.indecesToStay.push(i), this.result.attributes.push(cattr));
    }
    for (var i = 0; i < child_res.tuples.length; i++) {
        var projected_tuple = this.project(child_res.tuples[i]);
        this.result.tuples.pushDistinct(projected_tuple);
    }
    console.log(this.result);
}, Projection.prototype.project = function(tuple) {
    for (var newt = new Tuple(), i = 0; i < tuple.values.length; i++) -1 != this.indecesToStay.indexOf(i) && newt.values.push(tuple.values[i]);
    return newt;
}, Array.prototype.pushDistinct = function(x) {
    for (var i = 0; i < this.length; i++) {
        var equal = !0;
        for (j = 0; j < this[i].values.length; j++) equal = equal && this[i].values[j] == x.values[j];
        if (equal) return this.length;
    }
    this.push(x);
}, RelationRenaming.prototype.eval = function() {
    this.relation.eval();
}, ColumnRenaming.prototype.eval = function() {
    this.relation.eval(), console.log("# ColumnRenaming started"), this.buildAttrs();
    var child_res = this.relation.result;
    this.result = new Array();
    for (var i = 0; i < child_res.length; i++) console.log("# cr step " + i), this.result.push(this.applyRenaming(child_res[i]));
}, ColumnRenaming.prototype.applyRenaming = function(tuple) {
    var newTuple = {};
    for (var attr in tuple) for (var i = 0; i < this.renaming.length; i++) {
        var newname = this.renaming[i].newname;
        this.renaming[i].oldname == attr ? newTuple[newname] = tuple[attr] : newTuple[attr] = tuple[attr];
    }
    return newTuple;
}, ColumnRenaming.prototype.buildAttrs = function() {
    this.attrs = [];
    for (var i = 0; i < this.relation.attrs.length; i++) {
        for (var was_changed = !1, j = 0; j < this.renaming.length; j++) this.relation.attrs[i] == this.renaming[j].oldname && (was_changed = !0, 
        this.attrs.push(this.renaming[j].newname));
        was_changed || this.attrs.push(this.relation.attrs[i]);
    }
    console.log(this.relation.attrs), console.log(this.attrs);
}, Selection.prototype.eval = function() {
    this.relation.eval();
    var child_res = this.relation.result;
    this.result = new Relation(), this.result.attributes = this.relation.result.attributes, 
    this.result.tuples = new Array();
    for (var i = 0; i < child_res.tuples.length; i++) this.predicate(child_res.tuples[i]) && this.result.tuples.push(child_res.tuples[i]);
}, Selection.prototype.getAttr = function(attrname) {
    var attr_index;
    if (-1 === attrname.indexOf(".")) for (var i = 0; i < this.result.attributes.length; i++) this.result.attributes[i][1] == attrname && (attr_index = i); else for (var x = attrname.split("."), i = 0; i < this.result.attributes.length; i++) this.result.attributes[i][0] == x[0] && this.result.attributes[i][1] == x[1] && (attr_index = i);
    return attr_index;
}, QueryParser = function() {
    function peg$subclass(child, parent) {
        function ctor() {
            this.constructor = child;
        }
        ctor.prototype = parent.prototype, child.prototype = new ctor();
    }
    function SyntaxError(message, expected, found, offset, line, column) {
        this.message = message, this.expected = expected, this.found = found, this.offset = offset, 
        this.line = line, this.column = column, this.name = "SyntaxError";
    }
    function parse(input) {
        function peg$computePosDetails(pos) {
            function advance(details, startPos, endPos) {
                var p, ch;
                for (p = startPos; endPos > p; p++) ch = input.charAt(p), "\n" === ch ? (details.seenCR || details.line++, 
                details.column = 1, details.seenCR = !1) : "\r" === ch || "\u2028" === ch || "\u2029" === ch ? (details.line++, 
                details.column = 1, details.seenCR = !0) : (details.column++, details.seenCR = !1);
            }
            return peg$cachedPos !== pos && (peg$cachedPos > pos && (peg$cachedPos = 0, peg$cachedPosDetails = {
                line: 1,
                column: 1,
                seenCR: !1
            }), advance(peg$cachedPosDetails, peg$cachedPos, pos), peg$cachedPos = pos), peg$cachedPosDetails;
        }
        function peg$fail(expected) {
            peg$maxFailPos > peg$currPos || (peg$currPos > peg$maxFailPos && (peg$maxFailPos = peg$currPos, 
            peg$maxFailExpected = []), peg$maxFailExpected.push(expected));
        }
        function peg$buildException(message, expected, pos) {
            function cleanupExpected(expected) {
                var i = 1;
                for (expected.sort(function(a, b) {
                    return a.description < b.description ? -1 : a.description > b.description ? 1 : 0;
                }); i < expected.length; ) expected[i - 1] === expected[i] ? expected.splice(i, 1) : i++;
            }
            function buildMessage(expected, found) {
                function stringEscape(s) {
                    function hex(ch) {
                        return ch.charCodeAt(0).toString(16).toUpperCase();
                    }
                    return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
                        return "\\x0" + hex(ch);
                    }).replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
                        return "\\x" + hex(ch);
                    }).replace(/[\u0180-\u0FFF]/g, function(ch) {
                        return "\\u0" + hex(ch);
                    }).replace(/[\u1080-\uFFFF]/g, function(ch) {
                        return "\\u" + hex(ch);
                    });
                }
                var expectedDesc, foundDesc, i, expectedDescs = new Array(expected.length);
                for (i = 0; i < expected.length; i++) expectedDescs[i] = expected[i].description;
                return expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected.length - 1] : expectedDescs[0], 
                foundDesc = found ? '"' + stringEscape(found) + '"' : "end of input", "Expected " + expectedDesc + " but " + foundDesc + " found.";
            }
            var posDetails = peg$computePosDetails(pos), found = pos < input.length ? input.charAt(pos) : null;
            return null !== expected && cleanupExpected(expected), new SyntaxError(null !== message ? message : buildMessage(expected, found), expected, found, pos, posDetails.line, posDetails.column);
        }
        function peg$parsestart() {
            var s0, key = 17 * peg$currPos + 0, cached = peg$cache[key];
            return cached ? (peg$currPos = cached.nextPos, cached.result) : (s0 = peg$parserelation(), 
            peg$cache[key] = {
                nextPos: peg$currPos,
                result: s0
            }, s0);
        }
        function peg$parserelation() {
            var s0, key = 17 * peg$currPos + 1, cached = peg$cache[key];
            return cached ? (peg$currPos = cached.nextPos, cached.result) : (s0 = peg$parsebaseRelation(), 
            s0 === peg$FAILED && (s0 = peg$parseselection(), s0 === peg$FAILED && (s0 = peg$parseprojection(), 
            s0 === peg$FAILED && (s0 = peg$parserelation_renaming(), s0 === peg$FAILED && (s0 = peg$parsecolumn_renaming(), 
            s0 === peg$FAILED && (s0 = peg$parsecross(), s0 === peg$FAILED && (s0 = peg$parsejoin())))))), 
            peg$cache[key] = {
                nextPos: peg$currPos,
                result: s0
            }, s0);
        }
        function peg$parsebaseRelation() {
            var s0, s1, key = 17 * peg$currPos + 2, cached = peg$cache[key];
            return cached ? (peg$currPos = cached.nextPos, cached.result) : (s0 = peg$currPos, 
            s1 = peg$parserelationName(), s1 !== peg$FAILED && (peg$reportedPos = s0, s1 = peg$c0(s1)), 
            s0 = s1, peg$cache[key] = {
                nextPos: peg$currPos,
                result: s0
            }, s0);
        }
        function peg$parserelationName() {
            var s0, s1, s2, key = 17 * peg$currPos + 3, cached = peg$cache[key];
            if (cached) return peg$currPos = cached.nextPos, cached.result;
            if (s0 = peg$currPos, s1 = [], peg$c3.test(input.charAt(peg$currPos)) ? (s2 = input.charAt(peg$currPos), 
            peg$currPos++) : (s2 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c4)), s2 !== peg$FAILED) for (;s2 !== peg$FAILED; ) s1.push(s2), 
            peg$c3.test(input.charAt(peg$currPos)) ? (s2 = input.charAt(peg$currPos), peg$currPos++) : (s2 = peg$FAILED, 
            0 === peg$silentFails && peg$fail(peg$c4)); else s1 = peg$c2;
            return s1 !== peg$FAILED && (peg$reportedPos = s0, s1 = peg$c5(s1)), s0 = s1, peg$cache[key] = {
                nextPos: peg$currPos,
                result: s0
            }, s0;
        }
        function peg$parseattrName() {
            var s0, s1, s2, s3, s4, key = 17 * peg$currPos + 4, cached = peg$cache[key];
            if (cached) return peg$currPos = cached.nextPos, cached.result;
            if (s0 = peg$currPos, s1 = peg$parserelationName(), s1 !== peg$FAILED) if (46 === input.charCodeAt(peg$currPos) ? (s2 = peg$c6, 
            peg$currPos++) : (s2 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c7)), s2 !== peg$FAILED) {
                if (s3 = [], peg$c3.test(input.charAt(peg$currPos)) ? (s4 = input.charAt(peg$currPos), 
                peg$currPos++) : (s4 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c4)), s4 !== peg$FAILED) for (;s4 !== peg$FAILED; ) s3.push(s4), 
                peg$c3.test(input.charAt(peg$currPos)) ? (s4 = input.charAt(peg$currPos), peg$currPos++) : (s4 = peg$FAILED, 
                0 === peg$silentFails && peg$fail(peg$c4)); else s3 = peg$c2;
                s3 !== peg$FAILED ? (peg$reportedPos = s0, s1 = peg$c8(s1, s3), s0 = s1) : (peg$currPos = s0, 
                s0 = peg$c2);
            } else peg$currPos = s0, s0 = peg$c2; else peg$currPos = s0, s0 = peg$c2;
            if (s0 === peg$FAILED) {
                if (s0 = peg$currPos, s1 = [], peg$c3.test(input.charAt(peg$currPos)) ? (s2 = input.charAt(peg$currPos), 
                peg$currPos++) : (s2 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c4)), s2 !== peg$FAILED) for (;s2 !== peg$FAILED; ) s1.push(s2), 
                peg$c3.test(input.charAt(peg$currPos)) ? (s2 = input.charAt(peg$currPos), peg$currPos++) : (s2 = peg$FAILED, 
                0 === peg$silentFails && peg$fail(peg$c4)); else s1 = peg$c2;
                s1 !== peg$FAILED && (peg$reportedPos = s0, s1 = peg$c5(s1)), s0 = s1;
            }
            return peg$cache[key] = {
                nextPos: peg$currPos,
                result: s0
            }, s0;
        }
        function peg$parseselection() {
            var s0, s1, s2, s3, s4, s5, key = 17 * peg$currPos + 5, cached = peg$cache[key];
            return cached ? (peg$currPos = cached.nextPos, cached.result) : (s0 = peg$currPos, 
            input.substr(peg$currPos, 7) === peg$c9 ? (s1 = peg$c9, peg$currPos += 7) : (s1 = peg$FAILED, 
            0 === peg$silentFails && peg$fail(peg$c10)), s1 !== peg$FAILED ? (s2 = peg$parsepredicate(), 
            s2 !== peg$FAILED ? (input.substr(peg$currPos, 2) === peg$c11 ? (s3 = peg$c11, peg$currPos += 2) : (s3 = peg$FAILED, 
            0 === peg$silentFails && peg$fail(peg$c12)), s3 !== peg$FAILED ? (s4 = peg$parserelation(), 
            s4 !== peg$FAILED ? (41 === input.charCodeAt(peg$currPos) ? (s5 = peg$c13, peg$currPos++) : (s5 = peg$FAILED, 
            0 === peg$silentFails && peg$fail(peg$c14)), s5 !== peg$FAILED ? (peg$reportedPos = s0, 
            s1 = peg$c15(s2, s4), s0 = s1) : (peg$currPos = s0, s0 = peg$c2)) : (peg$currPos = s0, 
            s0 = peg$c2)) : (peg$currPos = s0, s0 = peg$c2)) : (peg$currPos = s0, s0 = peg$c2)) : (peg$currPos = s0, 
            s0 = peg$c2), peg$cache[key] = {
                nextPos: peg$currPos,
                result: s0
            }, s0);
        }
        function peg$parsepredicate() {
            var s0, s1, s2, s3, s4, s5, key = 17 * peg$currPos + 6, cached = peg$cache[key];
            if (cached) return peg$currPos = cached.nextPos, cached.result;
            if (s0 = peg$currPos, s1 = peg$parsepredicateEl(), s1 !== peg$FAILED) {
                for (s2 = [], peg$c16.test(input.charAt(peg$currPos)) ? (s3 = input.charAt(peg$currPos), 
                peg$currPos++) : (s3 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c17)); s3 !== peg$FAILED; ) s2.push(s3), 
                peg$c16.test(input.charAt(peg$currPos)) ? (s3 = input.charAt(peg$currPos), peg$currPos++) : (s3 = peg$FAILED, 
                0 === peg$silentFails && peg$fail(peg$c17));
                if (s2 !== peg$FAILED) if (s3 = peg$parsepredicateOp(), s3 !== peg$FAILED) {
                    for (s4 = [], peg$c16.test(input.charAt(peg$currPos)) ? (s5 = input.charAt(peg$currPos), 
                    peg$currPos++) : (s5 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c17)); s5 !== peg$FAILED; ) s4.push(s5), 
                    peg$c16.test(input.charAt(peg$currPos)) ? (s5 = input.charAt(peg$currPos), peg$currPos++) : (s5 = peg$FAILED, 
                    0 === peg$silentFails && peg$fail(peg$c17));
                    s4 !== peg$FAILED ? (s5 = peg$parsepredicateEl(), s5 !== peg$FAILED ? (peg$reportedPos = s0, 
                    s1 = peg$c18(s1, s3, s5), s0 = s1) : (peg$currPos = s0, s0 = peg$c2)) : (peg$currPos = s0, 
                    s0 = peg$c2);
                } else peg$currPos = s0, s0 = peg$c2; else peg$currPos = s0, s0 = peg$c2;
            } else peg$currPos = s0, s0 = peg$c2;
            return peg$cache[key] = {
                nextPos: peg$currPos,
                result: s0
            }, s0;
        }
        function peg$parsepredicateOp() {
            var s0, key = 17 * peg$currPos + 7, cached = peg$cache[key];
            return cached ? (peg$currPos = cached.nextPos, cached.result) : (input.substr(peg$currPos, 2) === peg$c19 ? (s0 = peg$c19, 
            peg$currPos += 2) : (s0 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c20)), 
            s0 === peg$FAILED && (input.substr(peg$currPos, 2) === peg$c21 ? (s0 = peg$c21, 
            peg$currPos += 2) : (s0 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c22)), 
            s0 === peg$FAILED && (input.substr(peg$currPos, 2) === peg$c23 ? (s0 = peg$c23, 
            peg$currPos += 2) : (s0 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c24)), 
            s0 === peg$FAILED && (input.substr(peg$currPos, 2) === peg$c25 ? (s0 = peg$c25, 
            peg$currPos += 2) : (s0 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c26)), 
            s0 === peg$FAILED && (60 === input.charCodeAt(peg$currPos) ? (s0 = peg$c27, peg$currPos++) : (s0 = peg$FAILED, 
            0 === peg$silentFails && peg$fail(peg$c28)), s0 === peg$FAILED && (62 === input.charCodeAt(peg$currPos) ? (s0 = peg$c29, 
            peg$currPos++) : (s0 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c30))))))), 
            peg$cache[key] = {
                nextPos: peg$currPos,
                result: s0
            }, s0);
        }
        function peg$parsepredicateEl() {
            var s0, s1, s2, s3, key = 17 * peg$currPos + 8, cached = peg$cache[key];
            if (cached) return peg$currPos = cached.nextPos, cached.result;
            if (s0 = peg$currPos, s1 = peg$parseattrName(), s1 !== peg$FAILED && (peg$reportedPos = s0, 
            s1 = peg$c31(s1)), s0 = s1, s0 === peg$FAILED) {
                if (s0 = peg$currPos, 34 === input.charCodeAt(peg$currPos) ? (s1 = peg$c32, peg$currPos++) : (s1 = peg$FAILED, 
                0 === peg$silentFails && peg$fail(peg$c33)), s1 !== peg$FAILED) {
                    if (s2 = [], peg$c34.test(input.charAt(peg$currPos)) ? (s3 = input.charAt(peg$currPos), 
                    peg$currPos++) : (s3 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c35)), 
                    s3 !== peg$FAILED) for (;s3 !== peg$FAILED; ) s2.push(s3), peg$c34.test(input.charAt(peg$currPos)) ? (s3 = input.charAt(peg$currPos), 
                    peg$currPos++) : (s3 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c35)); else s2 = peg$c2;
                    s2 !== peg$FAILED ? (34 === input.charCodeAt(peg$currPos) ? (s3 = peg$c32, peg$currPos++) : (s3 = peg$FAILED, 
                    0 === peg$silentFails && peg$fail(peg$c33)), s3 !== peg$FAILED ? (peg$reportedPos = s0, 
                    s1 = peg$c36(s2), s0 = s1) : (peg$currPos = s0, s0 = peg$c2)) : (peg$currPos = s0, 
                    s0 = peg$c2);
                } else peg$currPos = s0, s0 = peg$c2;
                if (s0 === peg$FAILED) {
                    if (s0 = peg$currPos, s1 = [], peg$c37.test(input.charAt(peg$currPos)) ? (s2 = input.charAt(peg$currPos), 
                    peg$currPos++) : (s2 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c38)), 
                    s2 !== peg$FAILED) for (;s2 !== peg$FAILED; ) s1.push(s2), peg$c37.test(input.charAt(peg$currPos)) ? (s2 = input.charAt(peg$currPos), 
                    peg$currPos++) : (s2 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c38)); else s1 = peg$c2;
                    s1 !== peg$FAILED && (peg$reportedPos = s0, s1 = peg$c39(s1)), s0 = s1;
                }
            }
            return peg$cache[key] = {
                nextPos: peg$currPos,
                result: s0
            }, s0;
        }
        function peg$parseprojection() {
            var s0, s1, s2, s3, s4, s5, key = 17 * peg$currPos + 9, cached = peg$cache[key];
            return cached ? (peg$currPos = cached.nextPos, cached.result) : (s0 = peg$currPos, 
            input.substr(peg$currPos, 4) === peg$c40 ? (s1 = peg$c40, peg$currPos += 4) : (s1 = peg$FAILED, 
            0 === peg$silentFails && peg$fail(peg$c41)), s1 !== peg$FAILED ? (s2 = peg$parseattrList(), 
            s2 !== peg$FAILED ? (input.substr(peg$currPos, 2) === peg$c11 ? (s3 = peg$c11, peg$currPos += 2) : (s3 = peg$FAILED, 
            0 === peg$silentFails && peg$fail(peg$c12)), s3 !== peg$FAILED ? (s4 = peg$parserelation(), 
            s4 !== peg$FAILED ? (41 === input.charCodeAt(peg$currPos) ? (s5 = peg$c13, peg$currPos++) : (s5 = peg$FAILED, 
            0 === peg$silentFails && peg$fail(peg$c14)), s5 !== peg$FAILED ? (peg$reportedPos = s0, 
            s1 = peg$c42(s2, s4), s0 = s1) : (peg$currPos = s0, s0 = peg$c2)) : (peg$currPos = s0, 
            s0 = peg$c2)) : (peg$currPos = s0, s0 = peg$c2)) : (peg$currPos = s0, s0 = peg$c2)) : (peg$currPos = s0, 
            s0 = peg$c2), peg$cache[key] = {
                nextPos: peg$currPos,
                result: s0
            }, s0);
        }
        function peg$parseattrList() {
            var s0, s1, s2, s3, s4, key = 17 * peg$currPos + 10, cached = peg$cache[key];
            if (cached) return peg$currPos = cached.nextPos, cached.result;
            if (s0 = peg$currPos, s1 = peg$parseattrName(), s1 !== peg$FAILED) if (44 === input.charCodeAt(peg$currPos) ? (s2 = peg$c43, 
            peg$currPos++) : (s2 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c44)), 
            s2 !== peg$FAILED) {
                for (s3 = [], peg$c16.test(input.charAt(peg$currPos)) ? (s4 = input.charAt(peg$currPos), 
                peg$currPos++) : (s4 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c17)); s4 !== peg$FAILED; ) s3.push(s4), 
                peg$c16.test(input.charAt(peg$currPos)) ? (s4 = input.charAt(peg$currPos), peg$currPos++) : (s4 = peg$FAILED, 
                0 === peg$silentFails && peg$fail(peg$c17));
                s3 !== peg$FAILED ? (s4 = peg$parseattrList(), s4 !== peg$FAILED ? (peg$reportedPos = s0, 
                s1 = peg$c45(s1, s4), s0 = s1) : (peg$currPos = s0, s0 = peg$c2)) : (peg$currPos = s0, 
                s0 = peg$c2);
            } else peg$currPos = s0, s0 = peg$c2; else peg$currPos = s0, s0 = peg$c2;
            return s0 === peg$FAILED && (s0 = peg$currPos, s1 = peg$parseattrName(), s1 !== peg$FAILED && (peg$reportedPos = s0, 
            s1 = peg$c46(s1)), s0 = s1), peg$cache[key] = {
                nextPos: peg$currPos,
                result: s0
            }, s0;
        }
        function peg$parserelation_renaming() {
            var s0, s1, s2, s3, s4, s5, key = 17 * peg$currPos + 11, cached = peg$cache[key];
            return cached ? (peg$currPos = cached.nextPos, cached.result) : (s0 = peg$currPos, 
            input.substr(peg$currPos, 5) === peg$c47 ? (s1 = peg$c47, peg$currPos += 5) : (s1 = peg$FAILED, 
            0 === peg$silentFails && peg$fail(peg$c48)), s1 !== peg$FAILED ? (s2 = peg$parserelationName(), 
            s2 !== peg$FAILED ? (input.substr(peg$currPos, 2) === peg$c11 ? (s3 = peg$c11, peg$currPos += 2) : (s3 = peg$FAILED, 
            0 === peg$silentFails && peg$fail(peg$c12)), s3 !== peg$FAILED ? (s4 = peg$parserelation(), 
            s4 !== peg$FAILED ? (41 === input.charCodeAt(peg$currPos) ? (s5 = peg$c13, peg$currPos++) : (s5 = peg$FAILED, 
            0 === peg$silentFails && peg$fail(peg$c14)), s5 !== peg$FAILED ? (peg$reportedPos = s0, 
            s1 = peg$c49(s2, s4), s0 = s1) : (peg$currPos = s0, s0 = peg$c2)) : (peg$currPos = s0, 
            s0 = peg$c2)) : (peg$currPos = s0, s0 = peg$c2)) : (peg$currPos = s0, s0 = peg$c2)) : (peg$currPos = s0, 
            s0 = peg$c2), peg$cache[key] = {
                nextPos: peg$currPos,
                result: s0
            }, s0);
        }
        function peg$parsecolumn_renaming() {
            var s0, s1, s2, s3, s4, s5, key = 17 * peg$currPos + 12, cached = peg$cache[key];
            return cached ? (peg$currPos = cached.nextPos, cached.result) : (s0 = peg$currPos, 
            input.substr(peg$currPos, 5) === peg$c47 ? (s1 = peg$c47, peg$currPos += 5) : (s1 = peg$FAILED, 
            0 === peg$silentFails && peg$fail(peg$c48)), s1 !== peg$FAILED ? (s2 = peg$parserenameOps(), 
            s2 !== peg$FAILED ? (input.substr(peg$currPos, 2) === peg$c11 ? (s3 = peg$c11, peg$currPos += 2) : (s3 = peg$FAILED, 
            0 === peg$silentFails && peg$fail(peg$c12)), s3 !== peg$FAILED ? (s4 = peg$parserelation(), 
            s4 !== peg$FAILED ? (41 === input.charCodeAt(peg$currPos) ? (s5 = peg$c13, peg$currPos++) : (s5 = peg$FAILED, 
            0 === peg$silentFails && peg$fail(peg$c14)), s5 !== peg$FAILED ? (peg$reportedPos = s0, 
            s1 = peg$c50(s2, s4), s0 = s1) : (peg$currPos = s0, s0 = peg$c2)) : (peg$currPos = s0, 
            s0 = peg$c2)) : (peg$currPos = s0, s0 = peg$c2)) : (peg$currPos = s0, s0 = peg$c2)) : (peg$currPos = s0, 
            s0 = peg$c2), peg$cache[key] = {
                nextPos: peg$currPos,
                result: s0
            }, s0);
        }
        function peg$parserenameOps() {
            var s0, s1, s2, s3, s4, s5, key = 17 * peg$currPos + 13, cached = peg$cache[key];
            if (cached) return peg$currPos = cached.nextPos, cached.result;
            if (s0 = peg$currPos, s1 = peg$parserenameOp(), s1 !== peg$FAILED) {
                for (s2 = [], peg$c16.test(input.charAt(peg$currPos)) ? (s3 = input.charAt(peg$currPos), 
                peg$currPos++) : (s3 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c17)); s3 !== peg$FAILED; ) s2.push(s3), 
                peg$c16.test(input.charAt(peg$currPos)) ? (s3 = input.charAt(peg$currPos), peg$currPos++) : (s3 = peg$FAILED, 
                0 === peg$silentFails && peg$fail(peg$c17));
                if (s2 !== peg$FAILED) if (44 === input.charCodeAt(peg$currPos) ? (s3 = peg$c43, 
                peg$currPos++) : (s3 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c44)), 
                s3 !== peg$FAILED) {
                    for (s4 = [], peg$c16.test(input.charAt(peg$currPos)) ? (s5 = input.charAt(peg$currPos), 
                    peg$currPos++) : (s5 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c17)); s5 !== peg$FAILED; ) s4.push(s5), 
                    peg$c16.test(input.charAt(peg$currPos)) ? (s5 = input.charAt(peg$currPos), peg$currPos++) : (s5 = peg$FAILED, 
                    0 === peg$silentFails && peg$fail(peg$c17));
                    s4 !== peg$FAILED ? (s5 = peg$parserenameOps(), s5 !== peg$FAILED ? (peg$reportedPos = s0, 
                    s1 = peg$c51(s1, s5), s0 = s1) : (peg$currPos = s0, s0 = peg$c2)) : (peg$currPos = s0, 
                    s0 = peg$c2);
                } else peg$currPos = s0, s0 = peg$c2; else peg$currPos = s0, s0 = peg$c2;
            } else peg$currPos = s0, s0 = peg$c2;
            return s0 === peg$FAILED && (s0 = peg$currPos, s1 = peg$parserenameOp(), s1 !== peg$FAILED && (peg$reportedPos = s0, 
            s1 = peg$c52(s1)), s0 = s1), peg$cache[key] = {
                nextPos: peg$currPos,
                result: s0
            }, s0;
        }
        function peg$parserenameOp() {
            var s0, s1, s2, s3, s4, s5, key = 17 * peg$currPos + 14, cached = peg$cache[key];
            if (cached) return peg$currPos = cached.nextPos, cached.result;
            if (s0 = peg$currPos, s1 = peg$parseattrName(), s1 !== peg$FAILED) {
                for (s2 = [], peg$c16.test(input.charAt(peg$currPos)) ? (s3 = input.charAt(peg$currPos), 
                peg$currPos++) : (s3 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c17)); s3 !== peg$FAILED; ) s2.push(s3), 
                peg$c16.test(input.charAt(peg$currPos)) ? (s3 = input.charAt(peg$currPos), peg$currPos++) : (s3 = peg$FAILED, 
                0 === peg$silentFails && peg$fail(peg$c17));
                if (s2 !== peg$FAILED) if (input.substr(peg$currPos, 2) === peg$c53 ? (s3 = peg$c53, 
                peg$currPos += 2) : (s3 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c54)), 
                s3 !== peg$FAILED) {
                    for (s4 = [], peg$c16.test(input.charAt(peg$currPos)) ? (s5 = input.charAt(peg$currPos), 
                    peg$currPos++) : (s5 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c17)); s5 !== peg$FAILED; ) s4.push(s5), 
                    peg$c16.test(input.charAt(peg$currPos)) ? (s5 = input.charAt(peg$currPos), peg$currPos++) : (s5 = peg$FAILED, 
                    0 === peg$silentFails && peg$fail(peg$c17));
                    s4 !== peg$FAILED ? (s5 = peg$parseattrName(), s5 !== peg$FAILED ? (peg$reportedPos = s0, 
                    s1 = peg$c55(s1, s5), s0 = s1) : (peg$currPos = s0, s0 = peg$c2)) : (peg$currPos = s0, 
                    s0 = peg$c2);
                } else peg$currPos = s0, s0 = peg$c2; else peg$currPos = s0, s0 = peg$c2;
            } else peg$currPos = s0, s0 = peg$c2;
            return s0 === peg$FAILED && (s0 = peg$parserelationName()), peg$cache[key] = {
                nextPos: peg$currPos,
                result: s0
            }, s0;
        }
        function peg$parsecross() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, key = 17 * peg$currPos + 15, cached = peg$cache[key];
            if (cached) return peg$currPos = cached.nextPos, cached.result;
            if (s0 = peg$currPos, 40 === input.charCodeAt(peg$currPos) ? (s1 = peg$c56, peg$currPos++) : (s1 = peg$FAILED, 
            0 === peg$silentFails && peg$fail(peg$c57)), s1 !== peg$FAILED) if (s2 = peg$parserelation(), 
            s2 !== peg$FAILED) if (41 === input.charCodeAt(peg$currPos) ? (s3 = peg$c13, peg$currPos++) : (s3 = peg$FAILED, 
            0 === peg$silentFails && peg$fail(peg$c14)), s3 !== peg$FAILED) {
                for (s4 = [], peg$c16.test(input.charAt(peg$currPos)) ? (s5 = input.charAt(peg$currPos), 
                peg$currPos++) : (s5 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c17)); s5 !== peg$FAILED; ) s4.push(s5), 
                peg$c16.test(input.charAt(peg$currPos)) ? (s5 = input.charAt(peg$currPos), peg$currPos++) : (s5 = peg$FAILED, 
                0 === peg$silentFails && peg$fail(peg$c17));
                if (s4 !== peg$FAILED) if (input.substr(peg$currPos, 6) === peg$c58 ? (s5 = peg$c58, 
                peg$currPos += 6) : (s5 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c59)), 
                s5 !== peg$FAILED) {
                    for (s6 = [], peg$c16.test(input.charAt(peg$currPos)) ? (s7 = input.charAt(peg$currPos), 
                    peg$currPos++) : (s7 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c17)); s7 !== peg$FAILED; ) s6.push(s7), 
                    peg$c16.test(input.charAt(peg$currPos)) ? (s7 = input.charAt(peg$currPos), peg$currPos++) : (s7 = peg$FAILED, 
                    0 === peg$silentFails && peg$fail(peg$c17));
                    s6 !== peg$FAILED ? (40 === input.charCodeAt(peg$currPos) ? (s7 = peg$c56, peg$currPos++) : (s7 = peg$FAILED, 
                    0 === peg$silentFails && peg$fail(peg$c57)), s7 !== peg$FAILED ? (s8 = peg$parserelation(), 
                    s8 !== peg$FAILED ? (41 === input.charCodeAt(peg$currPos) ? (s9 = peg$c13, peg$currPos++) : (s9 = peg$FAILED, 
                    0 === peg$silentFails && peg$fail(peg$c14)), s9 !== peg$FAILED ? (peg$reportedPos = s0, 
                    s1 = peg$c60(s2, s8), s0 = s1) : (peg$currPos = s0, s0 = peg$c2)) : (peg$currPos = s0, 
                    s0 = peg$c2)) : (peg$currPos = s0, s0 = peg$c2)) : (peg$currPos = s0, s0 = peg$c2);
                } else peg$currPos = s0, s0 = peg$c2; else peg$currPos = s0, s0 = peg$c2;
            } else peg$currPos = s0, s0 = peg$c2; else peg$currPos = s0, s0 = peg$c2; else peg$currPos = s0, 
            s0 = peg$c2;
            return peg$cache[key] = {
                nextPos: peg$currPos,
                result: s0
            }, s0;
        }
        function peg$parsejoin() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, key = 17 * peg$currPos + 16, cached = peg$cache[key];
            if (cached) return peg$currPos = cached.nextPos, cached.result;
            if (s0 = peg$currPos, 40 === input.charCodeAt(peg$currPos) ? (s1 = peg$c56, peg$currPos++) : (s1 = peg$FAILED, 
            0 === peg$silentFails && peg$fail(peg$c57)), s1 !== peg$FAILED) if (s2 = peg$parserelation(), 
            s2 !== peg$FAILED) if (41 === input.charCodeAt(peg$currPos) ? (s3 = peg$c13, peg$currPos++) : (s3 = peg$FAILED, 
            0 === peg$silentFails && peg$fail(peg$c14)), s3 !== peg$FAILED) {
                for (s4 = [], peg$c16.test(input.charAt(peg$currPos)) ? (s5 = input.charAt(peg$currPos), 
                peg$currPos++) : (s5 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c17)); s5 !== peg$FAILED; ) s4.push(s5), 
                peg$c16.test(input.charAt(peg$currPos)) ? (s5 = input.charAt(peg$currPos), peg$currPos++) : (s5 = peg$FAILED, 
                0 === peg$silentFails && peg$fail(peg$c17));
                if (s4 !== peg$FAILED) if (input.substr(peg$currPos, 6) === peg$c61 ? (s5 = peg$c61, 
                peg$currPos += 6) : (s5 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c62)), 
                s5 !== peg$FAILED) if (s6 = peg$parsepredicate(), s6 !== peg$FAILED) if (93 === input.charCodeAt(peg$currPos) ? (s7 = peg$c63, 
                peg$currPos++) : (s7 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c64)), 
                s7 !== peg$FAILED) {
                    for (s8 = [], peg$c16.test(input.charAt(peg$currPos)) ? (s9 = input.charAt(peg$currPos), 
                    peg$currPos++) : (s9 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c17)); s9 !== peg$FAILED; ) s8.push(s9), 
                    peg$c16.test(input.charAt(peg$currPos)) ? (s9 = input.charAt(peg$currPos), peg$currPos++) : (s9 = peg$FAILED, 
                    0 === peg$silentFails && peg$fail(peg$c17));
                    s8 !== peg$FAILED ? (40 === input.charCodeAt(peg$currPos) ? (s9 = peg$c56, peg$currPos++) : (s9 = peg$FAILED, 
                    0 === peg$silentFails && peg$fail(peg$c57)), s9 !== peg$FAILED ? (s10 = peg$parserelation(), 
                    s10 !== peg$FAILED ? (41 === input.charCodeAt(peg$currPos) ? (s11 = peg$c13, peg$currPos++) : (s11 = peg$FAILED, 
                    0 === peg$silentFails && peg$fail(peg$c14)), s11 !== peg$FAILED ? (peg$reportedPos = s0, 
                    s1 = peg$c65(s2, s6, s10), s0 = s1) : (peg$currPos = s0, s0 = peg$c2)) : (peg$currPos = s0, 
                    s0 = peg$c2)) : (peg$currPos = s0, s0 = peg$c2)) : (peg$currPos = s0, s0 = peg$c2);
                } else peg$currPos = s0, s0 = peg$c2; else peg$currPos = s0, s0 = peg$c2; else peg$currPos = s0, 
                s0 = peg$c2; else peg$currPos = s0, s0 = peg$c2;
            } else peg$currPos = s0, s0 = peg$c2; else peg$currPos = s0, s0 = peg$c2; else peg$currPos = s0, 
            s0 = peg$c2;
            if (s0 === peg$FAILED) if (s0 = peg$currPos, 40 === input.charCodeAt(peg$currPos) ? (s1 = peg$c56, 
            peg$currPos++) : (s1 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c57)), 
            s1 !== peg$FAILED) if (s2 = peg$parserelation(), s2 !== peg$FAILED) if (41 === input.charCodeAt(peg$currPos) ? (s3 = peg$c13, 
            peg$currPos++) : (s3 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c14)), 
            s3 !== peg$FAILED) {
                for (s4 = [], peg$c16.test(input.charAt(peg$currPos)) ? (s5 = input.charAt(peg$currPos), 
                peg$currPos++) : (s5 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c17)); s5 !== peg$FAILED; ) s4.push(s5), 
                peg$c16.test(input.charAt(peg$currPos)) ? (s5 = input.charAt(peg$currPos), peg$currPos++) : (s5 = peg$FAILED, 
                0 === peg$silentFails && peg$fail(peg$c17));
                if (s4 !== peg$FAILED) if (input.substr(peg$currPos, 5) === peg$c66 ? (s5 = peg$c66, 
                peg$currPos += 5) : (s5 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c67)), 
                s5 !== peg$FAILED) {
                    for (s6 = [], peg$c16.test(input.charAt(peg$currPos)) ? (s7 = input.charAt(peg$currPos), 
                    peg$currPos++) : (s7 = peg$FAILED, 0 === peg$silentFails && peg$fail(peg$c17)); s7 !== peg$FAILED; ) s6.push(s7), 
                    peg$c16.test(input.charAt(peg$currPos)) ? (s7 = input.charAt(peg$currPos), peg$currPos++) : (s7 = peg$FAILED, 
                    0 === peg$silentFails && peg$fail(peg$c17));
                    s6 !== peg$FAILED ? (40 === input.charCodeAt(peg$currPos) ? (s7 = peg$c56, peg$currPos++) : (s7 = peg$FAILED, 
                    0 === peg$silentFails && peg$fail(peg$c57)), s7 !== peg$FAILED ? (s8 = peg$parserelation(), 
                    s8 !== peg$FAILED ? (41 === input.charCodeAt(peg$currPos) ? (s9 = peg$c13, peg$currPos++) : (s9 = peg$FAILED, 
                    0 === peg$silentFails && peg$fail(peg$c14)), s9 !== peg$FAILED ? (peg$reportedPos = s0, 
                    s1 = peg$c68(s2, s8), s0 = s1) : (peg$currPos = s0, s0 = peg$c2)) : (peg$currPos = s0, 
                    s0 = peg$c2)) : (peg$currPos = s0, s0 = peg$c2)) : (peg$currPos = s0, s0 = peg$c2);
                } else peg$currPos = s0, s0 = peg$c2; else peg$currPos = s0, s0 = peg$c2;
            } else peg$currPos = s0, s0 = peg$c2; else peg$currPos = s0, s0 = peg$c2; else peg$currPos = s0, 
            s0 = peg$c2;
            return peg$cache[key] = {
                nextPos: peg$currPos,
                result: s0
            }, s0;
        }
        var peg$result, options = arguments.length > 1 ? arguments[1] : {}, peg$FAILED = {}, peg$startRuleFunctions = {
            start: peg$parsestart
        }, peg$startRuleFunction = peg$parsestart, peg$c0 = function(name) {
            return new BaseRelation(name);
        }, peg$c2 = peg$FAILED, peg$c3 = /^[a-zA-Z_]/, peg$c4 = {
            type: "class",
            value: "[a-zA-Z_]",
            description: "[a-zA-Z_]"
        }, peg$c5 = function(chars) {
            return chars.join("");
        }, peg$c6 = ".", peg$c7 = {
            type: "literal",
            value: ".",
            description: '"."'
        }, peg$c8 = function(rel, chars) {
            return rel + "." + chars.join("");
        }, peg$c9 = "\\sigma[", peg$c10 = {
            type: "literal",
            value: "\\sigma[",
            description: '"\\\\sigma["'
        }, peg$c11 = "](", peg$c12 = {
            type: "literal",
            value: "](",
            description: '"]("'
        }, peg$c13 = ")", peg$c14 = {
            type: "literal",
            value: ")",
            description: '")"'
        }, peg$c15 = function(pred, rel) {
            return new Selection(pred, rel);
        }, peg$c16 = /^[ ]/, peg$c17 = {
            type: "class",
            value: "[ ]",
            description: "[ ]"
        }, peg$c18 = function(fst, p, snd) {
            return Function("tuple", "console.log(" + fst + p + snd + "); return " + fst + p + snd);
        }, peg$c19 = "==", peg$c20 = {
            type: "literal",
            value: "==",
            description: '"=="'
        }, peg$c21 = "!=", peg$c22 = {
            type: "literal",
            value: "!=",
            description: '"!="'
        }, peg$c23 = "<=", peg$c24 = {
            type: "literal",
            value: "<=",
            description: '"<="'
        }, peg$c25 = ">=", peg$c26 = {
            type: "literal",
            value: ">=",
            description: '">="'
        }, peg$c27 = "<", peg$c28 = {
            type: "literal",
            value: "<",
            description: '"<"'
        }, peg$c29 = ">", peg$c30 = {
            type: "literal",
            value: ">",
            description: '">"'
        }, peg$c31 = function(a) {
            return "tuple.values[this.getAttr('" + a + "')]";
        }, peg$c32 = '"', peg$c33 = {
            type: "literal",
            value: '"',
            description: '"\\""'
        }, peg$c34 = /^[^"]/, peg$c35 = {
            type: "class",
            value: '[^"]',
            description: '[^"]'
        }, peg$c36 = function(a) {
            return '"' + a.join("") + '"';
        }, peg$c37 = /^[0-9]/, peg$c38 = {
            type: "class",
            value: "[0-9]",
            description: "[0-9]"
        }, peg$c39 = function(digits) {
            return parseInt(digits.join(""), 10);
        }, peg$c40 = "\\pi[", peg$c41 = {
            type: "literal",
            value: "\\pi[",
            description: '"\\\\pi["'
        }, peg$c42 = function(atts, rel) {
            return new Projection(atts, rel);
        }, peg$c43 = ",", peg$c44 = {
            type: "literal",
            value: ",",
            description: '","'
        }, peg$c45 = function(fst, snd) {
            return [ fst ].concat(snd);
        }, peg$c46 = function(fst) {
            return [ fst ];
        }, peg$c47 = "\\rho[", peg$c48 = {
            type: "literal",
            value: "\\rho[",
            description: '"\\\\rho["'
        }, peg$c49 = function(ren, rel) {
            return new RelationRenaming(ren, rel);
        }, peg$c50 = function(ren, rel) {
            return new ColumnRenaming(ren, rel);
        }, peg$c51 = function(op, ops) {
            return [ op ].concat(ops);
        }, peg$c52 = function(op) {
            return [ op ];
        }, peg$c53 = "<-", peg$c54 = {
            type: "literal",
            value: "<-",
            description: '"<-"'
        }, peg$c55 = function(fst, snd) {
            return {
                newname: fst,
                oldname: snd
            };
        }, peg$c56 = "(", peg$c57 = {
            type: "literal",
            value: "(",
            description: '"("'
        }, peg$c58 = "\\times", peg$c59 = {
            type: "literal",
            value: "\\times",
            description: '"\\\\times"'
        }, peg$c60 = function(fst, snd) {
            return new Cross(fst, snd);
        }, peg$c61 = "\\join[", peg$c62 = {
            type: "literal",
            value: "\\join[",
            description: '"\\\\join["'
        }, peg$c63 = "]", peg$c64 = {
            type: "literal",
            value: "]",
            description: '"]"'
        }, peg$c65 = function(fst, pred, snd) {
            return new ThetaJoin(fst, snd, pred);
        }, peg$c66 = "\\join", peg$c67 = {
            type: "literal",
            value: "\\join",
            description: '"\\\\join"'
        }, peg$c68 = function(fst, snd) {
            return new NaturalJoin(fst, snd);
        }, peg$currPos = 0, peg$reportedPos = 0, peg$cachedPos = 0, peg$cachedPosDetails = {
            line: 1,
            column: 1,
            seenCR: !1
        }, peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$cache = {};
        if ("startRule" in options) {
            if (!(options.startRule in peg$startRuleFunctions)) throw new Error("Can't start parsing from rule \"" + options.startRule + '".');
            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
        }
        if (peg$result = peg$startRuleFunction(), peg$result !== peg$FAILED && peg$currPos === input.length) return peg$result;
        throw peg$result !== peg$FAILED && peg$currPos < input.length && peg$fail({
            type: "end",
            description: "end of input"
        }), peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
    return peg$subclass(SyntaxError, Error), {
        SyntaxError: SyntaxError,
        parse: parse
    };
}(), Relation.prototype.addTuple = function(values) {
    var t = new Tuple(this.attributes, values);
    this.tuples.push(t);
}, window.onload = function() {
    makeTablesExpendable(), prepareExamples(), document.getElementById("computeitlikeabauss").onclick = execQuery, 
    document.getElementById("input").onkeypress = function(e) {
        e || (e = window.event);
        var keyCode = e.keyCode || e.which;
        "13" == keyCode && execQuery();
    };
};