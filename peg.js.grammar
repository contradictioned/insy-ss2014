/* Grammar for PEG.js, 
 * see http://pegjs.majda.cz/online
 *
 * Example expressions (should be valid)
 *   \sigma[A==B](SomeRel)
 *   \rho[A<-B](SomeRel)
 *   \pi[A,B,C](SomeRel)
 * Counterexamples (should not be valid)
 *   \sigma[B](SomeRel)
 */
{
  function BaseRelation(name) {
    this.name = name;
  }

  function Selection(predicate, relation) {
    this.predicate = predicate;
    this.relation = relation;
  }

  function Projection(attrlist, relation) {
    this.attrlist = attrlist;
    this.relation = relation;
  }

  function RelationRenaming(new_name, relation) {
    this.new_name = new_name;
    this.relation = relation;
  }

  function ColumnRenaming(renaming, relation) {
    this.renaming = renaming;
    this.relation = relation;
  }

  function Cross(left, right) {
    this.left = left;
    this.right = right;
  }
  
  function NaturalJoin(left, right) {
    this.left = left;
    this.right = right;
  }

  function ThetaJoin(left, right, pred) {
    this.left = left;
    this.right = right;
    this.pred = pred;
  }
}


start
 = relation

relation
 = baseRelation
 / selection
 / projection
 / relation_renaming
 / column_renaming
 / cross
 / join

baseRelation
 = name:relationName { return new BaseRelation(name) }

relationName
 = chars:[a-zA-Z_]+ { return chars.join("") }

attrName
 = rel:relationName '.' chars:[a-zA-Z_]+ { return rel + '.' + chars.join("") }
 / chars:[a-zA-Z_]+ { return chars.join("") }


/* Selection */
selection
 = '\\sigma['pred:predicate']('rel:relation')' { return new Selection(pred, rel) }
predicate
 = fst:predicateEl [ ]* p:predicateOp [ ]* snd:predicateEl { return Function("tuple", "return " + fst + p + snd) }
predicateOp
 = ('==' / '!=' / '<=' / '>=' / '<' / '>')
predicateEl
 = a:attrName { return "tuple['"+ a +"']"; } /* An attribute */
 / "\""a:[^"]+"\"" { return "\"" + a.join("") + "\""; } /* A constant string */
 / digits:[0-9]+ { return parseInt(digits.join(""), 10); }


/* Projection */

projection
 = '\\pi['atts:attrList']('rel:relation')' { return new Projection(atts, rel) }
attrList
 = fst:attrName ',' snd:attrList { return [fst].concat(snd) }
 / fst:attrName  { return [fst] }


/* Renaming */

relation_renaming
 = '\\rho[' ren:relationName '](' rel:relation ')' { return new RelationRenaming(ren, rel) }

column_renaming
 = '\\rho[' ren:renameOps '](' rel:relation ')' { return new ColumnRenaming(ren, rel) }

renameOps
 = op:renameOp [ ]* ',' [ ]* ops:renameOps { return [op].concat(ops) }
 / op:renameOp               { return [op] }

renameOp
 = fst:attrName [ ]* '<-' [ ]* snd:attrName { return {newname: fst, oldname: snd} }
 / relationName

/* Cross product */
cross
 = '(' fst:relation ')\\times(' snd:relation ')' { return new Cross(fst, snd) }

join
 = '(' fst:relation ')\\join[' pred:predicate '](' snd:relation ')' { return new ThetaJoin(fst, snd, pred) }
 / '(' fst:relation ')\\join(' snd:relation ')' { return new NaturalJoin(fst, snd) }